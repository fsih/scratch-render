{"version":3,"file":"scratch-render.js","sources":["webpack://ScratchRender/webpack/bootstrap","webpack://ScratchRender/./src/shaders/sprite.frag","webpack://ScratchRender/./src/shaders/sprite.vert","webpack://ScratchRender/src/Drawable.js","webpack://ScratchRender/src/Rectangle.js","webpack://ScratchRender/src/RenderConstants.js","webpack://ScratchRender/src/RenderWebGL.js","webpack://ScratchRender/src/SVGSkin.js","webpack://ScratchRender/src/ShaderManager.js","webpack://ScratchRender/src/index.js","webpack://ScratchRender/external \"events\"","webpack://ScratchRender/external \"hull.js\"","webpack://ScratchRender/external \"scratch-svg-renderer\"","webpack://ScratchRender/external \"twgl.js\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","module.exports = \"precision mediump float;\\nuniform sampler2D u_skin;\\nvarying vec2 v_texCoord;\\n\\nvoid main()\\n{\\n\\tvec2 texcoord0 = v_texCoord;\\n\\tgl_FragColor = texture2D(u_skin, texcoord0);\\n}\\n\"","module.exports = \"uniform mat4 u_projectionMatrix;\\nuniform mat4 u_modelMatrix;\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nvarying vec2 v_texCoord;\\n\\nvoid main() {\\n    gl_Position = u_projectionMatrix * u_modelMatrix * vec4(a_position, 0, 1);\\n    v_texCoord = a_texCoord;\\n}\\n\"","const twgl = require('twgl.js');\n\nconst Rectangle = require('./Rectangle');\nconst RenderConstants = require('./RenderConstants');\nconst SVGSkin = require('./SVGSkin');\n\nclass Drawable {\n    /**\n     * An object which can be drawn by the renderer.\n     * @todo double-buffer all rendering state (position, skin, effects, etc.)\n     * @param {!int} id - This Drawable's unique ID.\n     * @constructor\n     */\n    constructor (id) {\n        /** @type {!int} */\n        this._id = id;\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The model matrix, to concat with projection at draw time.\n             * @type {module:twgl/m4.Mat4}\n             */\n            u_modelMatrix: twgl.m4.identity()\n        };\n\n        this._position = twgl.v3.create(0, 0);\n        this._scale = twgl.v3.create(100, 100);\n        this._direction = 90;\n        this._transformDirty = true;\n        this._rotationMatrix = twgl.m4.identity();\n        this._rotationTransformDirty = true;\n        this._rotationAdjusted = twgl.v3.create();\n        this._rotationCenterDirty = true;\n        this._skinScale = twgl.v3.create(0, 0, 0);\n        this._skinScaleDirty = true;\n        this._inverseMatrix = twgl.m4.identity();\n        this._inverseTransformDirty = true;\n        this._visible = true;\n\n        /** @todo move convex hull functionality, maybe bounds functionality overall, to Skin classes */\n        this._convexHullPoints = null;\n    }\n\n    /**\n     * @returns {number} The ID for this Drawable.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {SVGSkin} the current skin for this Drawable.\n     */\n    get skin () {\n        return this._skin;\n    }\n\n    /**\n     * @param {SVGSkin} newSkin - A new Skin for this Drawable.\n     */\n    set skin (newSkin) {\n        this._skin = newSkin;\n    }\n\n    /**\n     * @returns {Array<number>} the current scaling percentages applied to this Drawable. [100,100] is normal size.\n     */\n    get scale () {\n        return [this._scale[0], this._scale[1]];\n    }\n\n    /**\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering this Drawable.\n     */\n    getUniforms () {\n        this._calculateTransform();\n        return this._uniforms;\n    }\n\n    /**\n     * @returns {boolean} whether this Drawable is visible.\n     */\n    getVisible () {\n        return this._visible;\n    }\n\n    /**\n     * Calculate the transform to use when rendering this Drawable.\n     * @private\n     */\n    _calculateTransform () {\n        // twgl version of the following in function work.\n        // const scaledSize = twgl.v3.divScalar(\n        //     twgl.v3.multiply(this.skin.size, this._scale),\n        //     100\n        // );\n        // // was NaN because the vectors have only 2 components.\n        // scaledSize[2] = 0;\n\n        // Locally assign skinSize to keep from having the Skin getter\n        // properties called twice.\n        const skinSize = this.skin.size;\n        const scaledSize = this._skinScale;\n        scaledSize[0] = skinSize[0] * this._scale[0] / 100;\n        scaledSize[1] = skinSize[1] * this._scale[1] / 100;\n\n        const modelMatrix = this._uniforms.u_modelMatrix;\n\n        // twgl version of the following in function work.\n        // twgl.m4.identity(modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._position, modelMatrix);\n        // twgl.m4.multiply(modelMatrix, this._rotationMatrix, modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._rotationAdjusted, modelMatrix);\n        // twgl.m4.scale(modelMatrix, scaledSize, modelMatrix);\n\n        // Drawable configures a 3D matrix for drawing in WebGL, but most values\n        // will never be set because the inputs are on the X and Y position axis\n        // and the Z rotation axis. Drawable can bring the work inside\n        // _calculateTransform and greatly reduce the ammount of math and array\n        // assignments needed.\n\n        const scale0 = this._skinScale[0];\n        const scale1 = this._skinScale[1];\n        const rotation00 = this._rotationMatrix[0];\n        const rotation01 = this._rotationMatrix[1];\n        const rotation10 = this._rotationMatrix[4];\n        const rotation11 = this._rotationMatrix[5];\n\n        // Commented assignments show what the values are when the matrix was\n        // instantiated. Those values will never change so they do not need to\n        // be reassigned.\n        modelMatrix[0] = scale0 * rotation00;\n        modelMatrix[1] = scale0 * rotation01;\n        // modelMatrix[2] = 0;\n        // modelMatrix[3] = 0;\n        modelMatrix[4] = scale1 * rotation10;\n        modelMatrix[5] = scale1 * rotation11;\n    }\n}\n\nmodule.exports = Drawable;\n","class Rectangle {\n    /**\n     * A utility for creating and comparing axis-aligned rectangles.\n     * Rectangles are always initialized to the \"largest possible rectangle\";\n     * use one of the init* methods below to set up a particular rectangle.\n     * @constructor\n     */\n    constructor () {\n        this.left = -Infinity;\n        this.right = Infinity;\n        this.bottom = -Infinity;\n        this.top = Infinity;\n    }\n\n    /**\n     * Initialize a Rectangle from given Scratch-coordinate bounds.\n     * @param {number} left Left bound of the rectangle.\n     * @param {number} right Right bound of the rectangle.\n     * @param {number} bottom Bottom bound of the rectangle.\n     * @param {number} top Top bound of the rectangle.\n     */\n    initFromBounds (left, right, bottom, top) {\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n        this.top = top;\n    }\n\n    /**\n     * Initialize a Rectangle to the minimum AABB around a set of points.\n     * @param {Array<Array<number>>} points Array of [x, y] points.\n     */\n    initFromPointsAABB (points) {\n        this.left = Infinity;\n        this.right = -Infinity;\n        this.top = -Infinity;\n        this.bottom = Infinity;\n\n        for (let i = 0; i < points.length; i++) {\n            const x = points[i][0];\n            const y = points[i][1];\n            if (x < this.left) {\n                this.left = x;\n            }\n            if (x > this.right) {\n                this.right = x;\n            }\n            if (y > this.top) {\n                this.top = y;\n            }\n            if (y < this.bottom) {\n                this.bottom = y;\n            }\n        }\n    }\n\n    /**\n     * Determine if this Rectangle intersects some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if intersecting.\n     * @return {boolean} True if this Rectangle intersects other.\n     */\n    intersects (other) {\n        return (\n            this.left <= other.right &&\n            other.left <= this.right &&\n            this.top >= other.bottom &&\n            other.top >= this.bottom\n        );\n    }\n\n    /**\n     * Determine if this Rectangle fully contains some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if fully contained.\n     * @return {boolean} True if this Rectangle fully contains other.\n     */\n    contains (other) {\n        return (\n            other.left > this.left &&\n            other.right < this.right &&\n            other.top < this.top &&\n            other.bottom > this.bottom\n        );\n    }\n\n    /**\n     * Clamp a Rectangle to bounds.\n     * @param {number} left Left clamp.\n     * @param {number} right Right clamp.\n     * @param {number} bottom Bottom clamp.\n     * @param {number} top Top clamp.\n     */\n    clamp (left, right, bottom, top) {\n        this.left = Math.max(this.left, left);\n        this.right = Math.min(this.right, right);\n        this.bottom = Math.max(this.bottom, bottom);\n        this.top = Math.min(this.top, top);\n        // Ensure rectangle coordinates in order.\n        this.left = Math.min(this.left, this.right);\n        this.right = Math.max(this.right, this.left);\n        this.bottom = Math.min(this.bottom, this.top);\n        this.top = Math.max(this.top, this.bottom);\n    }\n\n    /**\n     * Push out the Rectangle to integer bounds.\n     */\n    snapToInt () {\n        this.left = Math.floor(this.left);\n        this.right = Math.ceil(this.right);\n        this.bottom = Math.floor(this.bottom);\n        this.top = Math.ceil(this.top);\n    }\n\n    /**\n     * Compute the intersection of two bounding Rectangles.\n     * Could be an impossible box if they don't intersect.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static intersect (a, b, result = new Rectangle()) {\n        result.left = Math.max(a.left, b.left);\n        result.right = Math.min(a.right, b.right);\n        result.top = Math.min(a.top, b.top);\n        result.bottom = Math.max(a.bottom, b.bottom);\n\n        return result;\n    }\n\n    /**\n     * Compute the union of two bounding Rectangles.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static union (a, b, result = new Rectangle()) {\n        result.left = Math.min(a.left, b.left);\n        result.right = Math.max(a.right, b.right);\n        // Scratch Space - +y is up\n        result.top = Math.max(a.top, b.top);\n        result.bottom = Math.min(a.bottom, b.bottom);\n        return result;\n    }\n\n    /**\n     * Width of the Rectangle.\n     * @return {number} Width of rectangle.\n     */\n    get width () {\n        return Math.abs(this.left - this.right);\n    }\n\n    /**\n     * Height of the Rectangle.\n     * @return {number} Height of rectangle.\n     */\n    get height () {\n        return Math.abs(this.top - this.bottom);\n    }\n\n}\n\nmodule.exports = Rectangle;\n","/** @module RenderConstants */\n\n/**\n * Various constants meant for use throughout the renderer.\n * @enum\n */\nmodule.exports = {\n    /**\n     * The ID value to use for \"no item\" or when an object has been disposed.\n     * @const {int}\n     */\n    ID_NONE: -1,\n\n    /**\n     * Optimize for fewer than this number of Drawables sharing the same Skin.\n     * Going above this may cause middleware warnings or a performance penalty but should otherwise behave correctly.\n     * @const {int}\n     */\n    SKIN_SHARE_SOFT_LIMIT: 301,\n\n    /**\n     * @enum {string}\n     */\n    Events: {\n        /**\n         * NativeSizeChanged event\n         *\n         * @event RenderWebGL#event:NativeSizeChanged\n         * @type {object}\n         * @property {Array<int>} newSize - the new size of the renderer\n         */\n        NativeSizeChanged: 'NativeSizeChanged'\n    }\n};\n","const EventEmitter = require('events');\n\nconst hull = require('hull.js');\nconst twgl = require('twgl.js');\n\nconst Drawable = require('./Drawable');\nconst Rectangle = require('./Rectangle');\nconst ShaderManager = require('./ShaderManager');\nconst RenderConstants = require('./RenderConstants');\nconst SVGSkin = require('./SVGSkin');\n\nconst __candidatesBounds = new Rectangle();\nconst __touchingColor = new Uint8ClampedArray(4);\nconst __blendColor = new Uint8ClampedArray(4);\n\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nconst MAX_TOUCH_SIZE = [3, 3];\n\n\nclass RenderWebGL extends EventEmitter {\n    /**\n     * Ask TWGL to create a rendering context with the attributes used by this renderer.\n     * @param {canvas} canvas - attach the context to this canvas.\n     * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).\n     * @private\n     */\n    static _getContext (canvas) {\n        return twgl.getWebGLContext(canvas, {alpha: false, stencil: true});\n    }\n\n    /**\n     * Create a renderer for drawing Scratch sprites to a canvas using WebGL.\n     * Coordinates will default to Scratch 2.0 values if unspecified.\n     * The stage's \"native\" size will be calculated from the these coordinates.\n     * For example, the defaults result in a native size of 480x360.\n     * Queries such as \"touching color?\" will always execute at the native size.\n     * @see RenderWebGL#setStageSize\n     * @see RenderWebGL#resize\n     * @param {canvas} canvas The canvas to draw onto.\n     * @param {int} [xLeft=-240] The x-coordinate of the left edge.\n     * @param {int} [xRight=240] The x-coordinate of the right edge.\n     * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.\n     * @param {int} [yTop=180] The y-coordinate of the top edge.\n     * @constructor\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (canvas, xLeft, xRight, yBottom, yTop) {\n        super();\n\n        /** @type {WebGLRenderingContext} */\n        const gl = this._gl = RenderWebGL._getContext(canvas);\n        if (!gl) {\n            throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n        }\n        /** @type {Drawable[]} */\n        this._allDrawables = [];\n\n        /** @type {Skin[]} */\n        this._allSkins = [];\n\n        /** @type {Array<int>} */\n        this._drawList = [];\n\n        // A list of layer group names in the order they should appear\n        // from furthest back to furthest in front.\n        /** @type {Array<String>} */\n        this._groupOrdering = [];\n\n        /**\n         * @typedef LayerGroup\n         * @property {int} groupIndex The relative position of this layer group in the group ordering\n         * @property {int} drawListOffset The absolute position of this layer group in the draw list\n         * This number gets updated as drawables get added to or deleted from the draw list.\n         */\n\n        // Map of group name to layer group\n        /** @type {Object.<string, LayerGroup>} */\n        this._layerGroups = {};\n\n        /** @type {int} */\n        this._nextDrawableId = RenderConstants.ID_NONE + 1;\n\n        /** @type {int} */\n        this._nextSkinId = RenderConstants.ID_NONE + 1;\n\n        /** @type {ShaderManager} */\n        this._shaderManager = new ShaderManager(gl);\n\n        /** @type {module:twgl/m4.Mat4} */\n        this._projection = twgl.m4.identity();\n\n        /** @type {HTMLCanvasElement} */\n        this._tempCanvas = document.createElement('canvas');\n\n        /** @type {any} */\n        this._regionId = null;\n\n        /** @type {function} */\n        this._exitRegion = null;\n\n        /** @type {Array.<snapshotCallback>} */\n        this._snapshotCallbacks = [];\n\n        this._createGeometry();\n\n        this.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this.setBackgroundColor(1, 1, 1);\n        this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n        this.resize(this._nativeSize[0], this._nativeSize[1]);\n\n        gl.disable(gl.DEPTH_TEST);\n        /** @todo disable when no partial transparency? */\n        gl.enable(gl.BLEND);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n    }\n\n    /**\n     * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.\n     */\n    get gl () {\n        return this._gl;\n    }\n\n    /**\n     * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.\n     */\n    get canvas () {\n        return this._gl && this._gl.canvas;\n    }\n\n    /**\n     * Set the physical size of the stage in device-independent pixels.\n     * This will be multiplied by the device's pixel ratio on high-DPI displays.\n     * @param {int} pixelsWide The desired width in device-independent pixels.\n     * @param {int} pixelsTall The desired height in device-independent pixels.\n     */\n    resize (pixelsWide, pixelsTall) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        this._gl.canvas.width = pixelsWide * pixelRatio;\n        this._gl.canvas.height = pixelsTall * pixelRatio;\n    }\n\n    /**\n     * Set the background color for the stage. The stage will be cleared with this\n     * color each frame.\n     * @param {number} red The red component for the background.\n     * @param {number} green The green component for the background.\n     * @param {number} blue The blue component for the background.\n     */\n    setBackgroundColor (red, green, blue) {\n        this._backgroundColor = [red, green, blue, 1];\n    }\n\n    /**\n     * Set logical size of the stage in Scratch units.\n     * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.\n     * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.\n     * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.\n     * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.\n     */\n    setStageSize (xLeft, xRight, yBottom, yTop) {\n        this._xLeft = xLeft;\n        this._xRight = xRight;\n        this._yBottom = yBottom;\n        this._yTop = yTop;\n\n        // swap yBottom & yTop to fit Scratch convention of +y=up\n        this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n\n        this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n\n    /**\n     * Set the \"native\" size of the stage, which is used for pen, query renders, etc.\n     * @param {int} width - the new width to set.\n     * @param {int} height - the new height to set.\n     * @private\n     * @fires RenderWebGL#event:NativeSizeChanged\n     */\n    _setNativeSize (width, height) {\n        this._nativeSize = [width, height];\n        this.emit(RenderConstants.Events.NativeSizeChanged, {newSize: this._nativeSize});\n    }\n\n    /**\n     * Create a new SVG skin.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     * @returns {!int} the ID for the new skin.\n     */\n    createSVGSkin (svgData, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new Drawable and add it to the scene.\n     * @param {string} group Layer group to add the drawable to\n     * @returns {int} The ID of the new Drawable.\n     */\n    createDrawable (group) {\n        if (!group || !this._layerGroups.hasOwnProperty(group)) {\n            return;\n        }\n        const drawableID = this._nextDrawableId++;\n        const drawable = new Drawable(drawableID);\n        this._allDrawables[drawableID] = drawable;\n        this._addToDrawList(drawableID, group);\n\n        drawable.skin = null;\n\n        return drawableID;\n    }\n\n    /**\n     * Set the layer group ordering for the renderer.\n     * @param {Array<string>} groupOrdering The ordered array of layer group\n     * names\n     */\n    setLayerGroupOrdering (groupOrdering) {\n        this._groupOrdering = groupOrdering;\n        for (let i = 0; i < this._groupOrdering.length; i++) {\n            this._layerGroups[this._groupOrdering[i]] = {\n                groupIndex: i,\n                drawListOffset: 0\n            };\n        }\n    }\n\n    _addToDrawList (drawableID, group) {\n        const currentLayerGroup = this._layerGroups[group];\n        const currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n\n        const drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n        this._drawList.splice(drawListOffset, 0, drawableID);\n\n        this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n\n    _updateOffsets (updateType, currentGroupOrderingIndex) {\n        for (let i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n            const laterGroupName = this._groupOrdering[i];\n            if (updateType === 'add') {\n                this._layerGroups[laterGroupName].drawListOffset++;\n            } else if (updateType === 'delete'){\n                this._layerGroups[laterGroupName].drawListOffset--;\n            }\n        }\n    }\n\n    get _visibleDrawList () {\n        return this._drawList.filter(id => this._allDrawables[id]._visible);\n    }\n\n    // Given a layer group, return the index where it ends (non-inclusive),\n    // e.g. the returned index does not have a drawable from this layer group in it)\n    _endIndexForKnownLayerGroup (layerGroup) {\n        const groupIndex = layerGroup.groupIndex;\n        if (groupIndex === this._groupOrdering.length - 1) {\n            return this._drawList.length;\n        }\n        return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n\n    /**\n     * Draw all current drawables and present the frame on the canvas.\n     */\n    draw () {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n\n        twgl.bindFramebufferInfo(gl, null);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor.apply(gl, this._backgroundColor);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection);\n        if (this._snapshotCallbacks.length > 0) {\n            const snapshot = gl.canvas.toDataURL();\n            this._snapshotCallbacks.forEach(cb => cb(snapshot));\n            this._snapshotCallbacks = [];\n        }\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @param {int} drawableID The ID of the Drawable to update.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateDrawableProperties (drawableID, properties) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            /**\n             * @todo fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n             * Right now this happens so much on some projects that a warning or exception here can hang the browser.\n             */\n            return;\n        }\n        if ('skinId' in properties) {\n            drawable.skin = this._allSkins[properties.skinId];\n        }\n    }\n\n    /* ******\n     * Truly internal functions: these support the functions above.\n     ********/\n\n    /**\n     * Build geometry (vertex and index) buffers.\n     * @private\n     */\n    _createGeometry () {\n        const quad = {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    -0.5, -0.5,\n                    0.5, -0.5,\n                    -0.5, 0.5,\n                    -0.5, 0.5,\n                    0.5, -0.5,\n                    0.5, 0.5\n                ]\n            },\n            a_texCoord: {\n                numComponents: 2,\n                data: [\n                    1, 0,\n                    0, 0,\n                    1, 1,\n                    1, 1,\n                    0, 0,\n                    0, 1\n                ]\n            }\n        };\n        this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n\n    /**\n     * Respond to a change in the \"native\" rendering size. The native size is used by buffers which are fixed in size\n     * regardless of the size of the main render target. This includes the buffers used for queries such as picking and\n     * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.\n     * @param {object} event - The change event.\n     * @private\n     */\n    onNativeSizeChanged (event) {\n        const [width, height] = event.newSize;\n\n        const gl = this._gl;\n        const attachments = [\n            {format: gl.RGBA},\n            {format: gl.DEPTH_STENCIL}\n        ];\n\n        if (!this._pickBufferInfo) {\n            this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n        }\n\n        /** @todo should we create this on demand to save memory? */\n        // A 480x360 32-bpp buffer is 675 KiB.\n        if (this._queryBufferInfo) {\n            twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n        } else {\n            this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n        }\n    }\n\n    /**\n     * Forcefully exit the current region returning to a common inbetween GL\n     * state.\n     */\n    _doExitDrawRegion () {\n        if (this._exitRegion !== null) {\n            this._exitRegion();\n        }\n        this._exitRegion = null;\n    }\n\n    /**\n     * Draw a set of Drawables, by drawable ID\n     * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.\n     * @param {module:twgl/m4.Mat4} projection The projection matrix to use.\n     * @param {object} [opts] Options for drawing\n     * @param {idFilterFunc} opts.filter An optional filter function.\n     * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.\n     * @param {int} opts.effectMask Bitmask for effects to allow\n     * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)\n     * @private\n     */\n    _drawThese (drawables, drawMode, projection, opts = {}) {\n\n        const gl = this._gl;\n        let currentShader = null;\n\n        const numDrawables = drawables.length;\n        for (let drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n            const drawableID = drawables[drawableIndex];\n\n            // If we have a filter, check whether the ID fails\n            if (opts.filter && !opts.filter(drawableID)) continue;\n\n            const drawable = this._allDrawables[drawableID];\n            /** @todo check if drawable is inside the viewport before anything else */\n\n            // Hidden drawables (e.g., by a \"hide\" block) are not drawn unless\n            // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).\n            if (!drawable.getVisible() && !opts.ignoreVisibility) continue;\n\n            // Combine drawable scale with the native vs. backing pixel ratio\n            const drawableScale = [\n                drawable.scale[0] * this._gl.canvas.width / this._nativeSize[0],\n                drawable.scale[1] * this._gl.canvas.height / this._nativeSize[1]\n            ];\n\n            // If the skin or texture isn't ready yet, skip it.\n            if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n\n            const uniforms = {};\n\n            const newShader = this._shaderManager.getShader(drawMode, 0);\n\n            // Manually perform region check. Do not create functions inside a\n            // loop.\n            if (this._regionId !== newShader) {\n                this._doExitDrawRegion();\n                this._regionId = newShader;\n\n                currentShader = newShader;\n                gl.useProgram(currentShader.program);\n                twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n                Object.assign(uniforms, {\n                    u_projectionMatrix: projection,\n                    u_fudge: window.fudge || 0\n                });\n            }\n\n            Object.assign(uniforms,\n                drawable.skin.getUniforms(),\n                drawable.getUniforms());\n\n            // Apply extra uniforms after the Drawable's, to allow overwriting.\n            if (opts.extraUniforms) {\n                Object.assign(uniforms, opts.extraUniforms);\n            }\n\n            if (uniforms.u_skin) {\n                twgl.setTextureParameters(gl, uniforms.u_skin, gl.LINEAR);\n            }\n\n            twgl.setUniforms(currentShader, uniforms);\n            \n            /* adjust blend function for this skin */\n            if (drawable.skin.hasPremultipliedAlpha){\n                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            } else {\n                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            }\n            \n            twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n        }\n\n        this._regionId = null;\n    }\n}\n\nmodule.exports = RenderWebGL;\n","const twgl = require('twgl.js');\nconst EventEmitter = require('events');\nconst SvgRenderer = require('scratch-svg-renderer').SVGRenderer;\n\nclass SVGSkin extends EventEmitter {\n    /**\n     * Create a new SVG skin.\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     * @constructor\n     * @extends Skin\n     */\n    constructor (id, renderer) {\n        super();\n\n        /** @type {int} */\n        this._id = id;\n\n        /** @type {Vec3} */\n        this._rotationCenter = twgl.v3.create(0, 0);\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The nominal (not necessarily current) size of the current skin.\n             * @type {Array<number>}\n             */\n            u_skinSize: [0, 0],\n\n            /**\n             * The actual WebGL texture object for the skin.\n             * @type {WebGLTexture}\n             */\n            u_skin: null\n        };\n\n        /** @type {RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {SvgRenderer} */\n        this._svgRenderer = new SvgRenderer();\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this skin.\n     */\n    get size () {\n        return this._svgRenderer.size;\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture () {\n        return this._texture;\n    }\n\n    /**\n     * @returns {Vec3} the origin, in object space, about which this Skin should rotate.\n     */\n    get rotationCenter () {\n        return this._rotationCenter;\n    }\n\n    /**\n     * Update and returns the uniforms for this skin.\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering with this Skin.\n     */\n    getUniforms () {\n        this._uniforms.u_skin = this.getTexture();\n        this._uniforms.u_skinSize = this.size;\n        return this._uniforms;\n    }\n\n    /**\n     * Set the origin, in object space, about which this Skin should rotate.\n     */\n    setRotationCenter () {\n        this._rotationCenter[0] = this.size[0] / 2;\n        this._rotationCenter[1] = this.size[1] / 2;\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided SVG data.\n     * @param {string} svgData - new SVG to use.\n     * calculated from the bounding box\n\\     */\n    setSVG (svgData) {\n        this._svgRenderer.fromString(svgData, 1, () => {\n            const gl = this._renderer.gl;\n\n            // Pull out the ImageData from the canvas. ImageData speeds up\n            // updating Silhouette and is better handled by more browsers in\n            // regards to memory.\n            const canvas = this._svgRenderer.canvas;\n            const context = canvas.getContext('2d');\n            const textureData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const textureOptions = {\n                auto: true,\n                wrap: gl.CLAMP_TO_EDGE,\n                src: textureData\n            };\n\n            this._texture = twgl.createTexture(gl, textureOptions);\n            this.setRotationCenter();\n        });\n    }\n\n}\n\nmodule.exports = SVGSkin;\n","const twgl = require('twgl.js');\n\n\nclass ShaderManager {\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for\n     * @constructor\n     */\n    constructor (gl) {\n        this._gl = gl;\n\n        /**\n         * The cache of all shaders compiled so far, filled on demand.\n         * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}\n         * @private\n         */\n        this._shaderCache = {};\n        for (const modeName in ShaderManager.DRAW_MODE) {\n            if (ShaderManager.DRAW_MODE.hasOwnProperty(modeName)) {\n                this._shaderCache[modeName] = [];\n            }\n        }\n    }\n\n    /**\n     * Fetch the shader for a particular set of active effects.\n     * Build the shader if necessary.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The shader's program info.\n     */\n    getShader (drawMode, effectBits) {\n        const cache = this._shaderCache[drawMode];\n        if (drawMode === ShaderManager.DRAW_MODE.silhouette) {\n            // Silhouette mode isn't affected by these effects.\n            effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);\n        }\n        let shader = cache[effectBits];\n        if (!shader) {\n            shader = cache[effectBits] = this._buildShader(drawMode, effectBits);\n        }\n        return shader;\n    }\n\n    /**\n     * Build the shader for a particular set of active effects.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The new shader's program info.\n     * @private\n     */\n    _buildShader (drawMode, effectBits) {\n        const numEffects = ShaderManager.EFFECTS.length;\n\n        const defines = [\n            `#define DRAW_MODE_${drawMode}`\n        ];\n        for (let index = 0; index < numEffects; ++index) {\n            if ((effectBits & (1 << index)) !== 0) {\n                defines.push(`#define ENABLE_${ShaderManager.EFFECTS[index]}`);\n            }\n        }\n\n        const definesText = `${defines.join('\\n')}\\n`;\n\n        /* eslint-disable global-require */\n        const vsFullText = definesText + require('raw-loader!./shaders/sprite.vert');\n        const fsFullText = definesText + require('raw-loader!./shaders/sprite.frag');\n        /* eslint-enable global-require */\n\n        return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);\n    }\n}\n\n/**\n * @typedef {object} ShaderManager.Effect\n * @prop {int} mask - The bit in 'effectBits' representing the effect.\n * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range\n *   0..100 or -100..100) and maps it to a value useful to the shader. This\n *   mapping may not be reversible.\n * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.\n */\n\n/**\n * Mapping of each effect name to info about that effect.\n * @enum {ShaderManager.Effect}\n */\nShaderManager.EFFECT_INFO = {\n    /** Color effect */\n    color: {\n        uniformName: 'u_color',\n        mask: 1 << 0,\n        converter: x => (x / 200) % 1,\n        shapeChanges: false\n    },\n    /** Fisheye effect */\n    fisheye: {\n        uniformName: 'u_fisheye',\n        mask: 1 << 1,\n        converter: x => Math.max(0, (x + 100) / 100),\n        shapeChanges: true\n    },\n    /** Whirl effect */\n    whirl: {\n        uniformName: 'u_whirl',\n        mask: 1 << 2,\n        converter: x => -x * Math.PI / 180,\n        shapeChanges: true\n    },\n    /** Pixelate effect */\n    pixelate: {\n        uniformName: 'u_pixelate',\n        mask: 1 << 3,\n        converter: x => Math.abs(x) / 10,\n        shapeChanges: true\n    },\n    /** Mosaic effect */\n    mosaic: {\n        uniformName: 'u_mosaic',\n        mask: 1 << 4,\n        converter: x => {\n            x = Math.round((Math.abs(x) + 10) / 10);\n            /** @todo cap by Math.min(srcWidth, srcHeight) */\n            return Math.max(1, Math.min(x, 512));\n        },\n        shapeChanges: true\n    },\n    /** Brightness effect */\n    brightness: {\n        uniformName: 'u_brightness',\n        mask: 1 << 5,\n        converter: x => Math.max(-100, Math.min(x, 100)) / 100,\n        shapeChanges: false\n    },\n    /** Ghost effect */\n    ghost: {\n        uniformName: 'u_ghost',\n        mask: 1 << 6,\n        converter: x => 1 - (Math.max(0, Math.min(x, 100)) / 100),\n        shapeChanges: false\n    }\n};\n\n/**\n * The name of each supported effect.\n * @type {Array}\n */\nShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);\n\n/**\n * The available draw modes.\n * @readonly\n * @enum {string}\n */\nShaderManager.DRAW_MODE = {\n    /**\n     * Draw normally.\n     */\n    default: 'default',\n\n    /**\n     * Draw a silhouette using a solid color.\n     */\n    silhouette: 'silhouette',\n\n    /**\n     * Draw only the parts of the drawable which match a particular color.\n     */\n    colorMask: 'colorMask',\n\n    /**\n     * Sample a \"texture\" to draw a line with caps.\n     */\n    lineSample: 'lineSample',\n\n    /**\n     * Draw normally except for pre-multiplied alpha\n     */\n    stamp: 'stamp'\n};\n\nmodule.exports = ShaderManager;\n","const RenderWebGL = require('./RenderWebGL');\n\n/**\n * Export for NPM & Node.js\n * @type {RenderWebGL}\n */\nmodule.exports = RenderWebGL;\n","module.exports = require(\"events\");","module.exports = require(\"hull.js\");","module.exports = require(\"scratch-svg-renderer\");","module.exports = require(\"twgl.js\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AALA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA3FA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;;;;AAuEA;;;;;;;;;;;;;;;;;;AClJA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAmCA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;AAxCA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAoBA;;;;;;;;;;;;;;AC1KA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AARA;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;;;;;;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;AAqEA;AACA;AACA;;;;;;;;;AAcA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AAFA;AAWA;AACA;AACA;AAFA;AAZA;AAwBA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA7VA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AA8HA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AA9OA;AACA;AAocA;;;;;;;;;;;;;;;;;;;;;;AC7dA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAqCA;AACA;AACA;;;;;;;;;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;;;AA9DA;AACA;AACA;;;AAcA;AACA;AACA;;;;AApEA;AACA;AAmHA;;;;;;;;;;;;;;;;;;ACxHA;AACA;AAEA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;AASA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAhDA;AACA;AAuDA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AAxBA;AACA;AA0BA;;;;;;;;;;;;;;ACrLA;AACA;AACA;;;;AAIA;;;;;;;;;;;ACNA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}