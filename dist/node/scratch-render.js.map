{"version":3,"file":"scratch-render.js","sources":["webpack://ScratchRender/webpack/bootstrap","webpack://ScratchRender/./src/shaders/sprite.frag","webpack://ScratchRender/./src/shaders/sprite.vert","webpack://ScratchRender/src/Drawable.js","webpack://ScratchRender/src/Rectangle.js","webpack://ScratchRender/src/RenderConstants.js","webpack://ScratchRender/src/RenderWebGL.js","webpack://ScratchRender/src/SVGSkin.js","webpack://ScratchRender/src/ShaderManager.js","webpack://ScratchRender/src/index.js","webpack://ScratchRender/external \"events\"","webpack://ScratchRender/external \"hull.js\"","webpack://ScratchRender/external \"scratch-svg-renderer\"","webpack://ScratchRender/external \"twgl.js\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","module.exports = \"precision mediump float;\\n\\nuniform float u_fudge;\\n\\n#ifdef DRAW_MODE_silhouette\\nuniform vec4 u_silhouetteColor;\\n#else // DRAW_MODE_silhouette\\n# ifdef ENABLE_color\\nuniform float u_color;\\n# endif // ENABLE_color\\n# ifdef ENABLE_brightness\\nuniform float u_brightness;\\n# endif // ENABLE_brightness\\n#endif // DRAW_MODE_silhouette\\n\\n#ifdef DRAW_MODE_colorMask\\nuniform vec3 u_colorMask;\\nuniform float u_colorMaskTolerance;\\n#endif // DRAW_MODE_colorMask\\n\\n#ifdef ENABLE_fisheye\\nuniform float u_fisheye;\\n#endif // ENABLE_fisheye\\n#ifdef ENABLE_whirl\\nuniform float u_whirl;\\n#endif // ENABLE_whirl\\n#ifdef ENABLE_pixelate\\nuniform float u_pixelate;\\nuniform vec2 u_skinSize;\\n#endif // ENABLE_pixelate\\n#ifdef ENABLE_mosaic\\nuniform float u_mosaic;\\n#endif // ENABLE_mosaic\\n#ifdef ENABLE_ghost\\nuniform float u_ghost;\\n#endif // ENABLE_ghost\\n\\n#ifdef DRAW_MODE_lineSample\\nuniform vec4 u_lineColor;\\nuniform float u_capScale;\\nuniform float u_aliasAmount;\\n#endif // DRAW_MODE_lineSample\\n\\nuniform sampler2D u_skin;\\n\\nvarying vec2 v_texCoord;\\n\\n#if !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n// Branchless color conversions based on code from:\\n// http://www.chilliant.com/rgb2hsv.html by Ian Taylor\\n// Based in part on work by Sam Hocevar and Emil Persson\\n// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation\\n\\n// Smaller values can cause problems on some mobile devices\\nconst float epsilon = 1e-3;\\n\\n// Convert an RGB color to Hue, Saturation, and Value.\\n// All components of input and output are expected to be in the [0,1] range.\\nvec3 convertRGB2HSV(vec3 rgb)\\n{\\n\\t// Hue calculation has 3 cases, depending on which RGB component is largest, and one of those cases involves a \\\"mod\\\"\\n\\t// operation. In order to avoid that \\\"mod\\\" we split the M==R case in two: one for G<B and one for B>G. The B>G case\\n\\t// will be calculated in the negative and fed through abs() in the hue calculation at the end.\\n\\t// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\\n\\tconst vec4 hueOffsets = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\n\\t// temp1.xy = sort B & G (largest first)\\n\\t// temp1.z = the hue offset we'll use if it turns out that R is the largest component (M==R)\\n\\t// temp1.w = the hue offset we'll use if it turns out that R is not the largest component (M==G or M==B)\\n\\tvec4 temp1 = rgb.b > rgb.g ? vec4(rgb.bg, hueOffsets.wz) : vec4(rgb.gb, hueOffsets.xy);\\n\\n\\t// temp2.x = the largest component of RGB (\\\"M\\\" / \\\"Max\\\")\\n\\t// temp2.yw = the smaller components of RGB, ordered for the hue calculation (not necessarily sorted by magnitude!)\\n\\t// temp2.z = the hue offset we'll use in the hue calculation\\n\\tvec4 temp2 = rgb.r > temp1.x ? vec4(rgb.r, temp1.yzx) : vec4(temp1.xyw, rgb.r);\\n\\n\\t// m = the smallest component of RGB (\\\"min\\\")\\n\\tfloat m = min(temp2.y, temp2.w);\\n\\n\\t// Chroma = M - m\\n\\tfloat C = temp2.x - m;\\n\\n\\t// Value = M\\n\\tfloat V = temp2.x;\\n\\n\\treturn vec3(\\n\\t\\tabs(temp2.z + (temp2.w - temp2.y) / (6.0 * C + epsilon)), // Hue\\n\\t\\tC / (temp2.x + epsilon), // Saturation\\n\\t\\tV); // Value\\n}\\n\\nvec3 convertHue2RGB(float hue)\\n{\\n\\tfloat r = abs(hue * 6.0 - 3.0) - 1.0;\\n\\tfloat g = 2.0 - abs(hue * 6.0 - 2.0);\\n\\tfloat b = 2.0 - abs(hue * 6.0 - 4.0);\\n\\treturn clamp(vec3(r, g, b), 0.0, 1.0);\\n}\\n\\nvec3 convertHSV2RGB(vec3 hsv)\\n{\\n\\tvec3 rgb = convertHue2RGB(hsv.x);\\n\\tfloat c = hsv.z * hsv.y;\\n\\treturn rgb * c + hsv.z - c;\\n}\\n#endif // !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n\\nconst vec2 kCenter = vec2(0.5, 0.5);\\n\\nvoid main()\\n{\\n\\t#ifndef DRAW_MODE_lineSample\\n\\tvec2 texcoord0 = v_texCoord;\\n\\n\\t#ifdef ENABLE_mosaic\\n\\ttexcoord0 = fract(u_mosaic * texcoord0);\\n\\t#endif // ENABLE_mosaic\\n\\n\\t#ifdef ENABLE_pixelate\\n\\t{\\n\\t\\t// TODO: clean up \\\"pixel\\\" edges\\n\\t\\tvec2 pixelTexelSize = u_skinSize / u_pixelate;\\n\\t\\ttexcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) / pixelTexelSize;\\n\\t}\\n\\t#endif // ENABLE_pixelate\\n\\n\\t#ifdef ENABLE_whirl\\n\\t{\\n\\t\\tconst float kRadius = 0.5;\\n\\t\\tvec2 offset = texcoord0 - kCenter;\\n\\t\\tfloat offsetMagnitude = length(offset);\\n\\t\\tfloat whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\\n\\t\\tfloat whirlActual = u_whirl * whirlFactor * whirlFactor;\\n\\t\\tfloat sinWhirl = sin(whirlActual);\\n\\t\\tfloat cosWhirl = cos(whirlActual);\\n\\t\\tmat2 rotationMatrix = mat2(\\n\\t\\t\\tcosWhirl, -sinWhirl,\\n\\t\\t\\tsinWhirl, cosWhirl\\n\\t\\t);\\n\\n\\t\\ttexcoord0 = rotationMatrix * offset + kCenter;\\n\\t}\\n\\t#endif // ENABLE_whirl\\n\\n\\t#ifdef ENABLE_fisheye\\n\\t{\\n\\t\\tvec2 vec = (texcoord0 - kCenter) / kCenter;\\n\\t\\tfloat vecLength = length(vec);\\n\\t\\tfloat r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\\n\\t\\tvec2 unit = vec / vecLength;\\n\\n\\t\\ttexcoord0 = kCenter + r * unit * kCenter;\\n\\t}\\n\\t#endif // ENABLE_fisheye\\n\\n\\tgl_FragColor = texture2D(u_skin, texcoord0);\\n\\n    #ifdef ENABLE_ghost\\n    gl_FragColor.a *= u_ghost;\\n    #endif // ENABLE_ghost\\n\\n\\t#ifdef DRAW_MODE_silhouette\\n\\t// switch to u_silhouetteColor only AFTER the alpha test\\n\\tgl_FragColor = u_silhouetteColor;\\n\\t#else // DRAW_MODE_silhouette\\n\\n\\t#if defined(ENABLE_color)\\n\\t{\\n\\t\\tvec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\\n\\n\\t\\t// this code forces grayscale values to be slightly saturated\\n\\t\\t// so that some slight change of hue will be visible\\n\\t\\tconst float minLightness = 0.11 / 2.0;\\n\\t\\tconst float minSaturation = 0.09;\\n\\t\\tif (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\\n\\t\\telse if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\\n\\n\\t\\thsv.x = mod(hsv.x + u_color, 1.0);\\n\\t\\tif (hsv.x < 0.0) hsv.x += 1.0;\\n\\n\\t\\tgl_FragColor.rgb = convertHSV2RGB(hsv);\\n\\t}\\n\\t#endif // defined(ENABLE_color)\\n\\n\\t#if defined(ENABLE_brightness)\\n\\tgl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\\n\\t#endif // defined(ENABLE_brightness)\\n\\n\\t#ifdef DRAW_MODE_colorMask\\n\\tvec3 maskDistance = abs(gl_FragColor.rgb - u_colorMask);\\n\\tvec3 colorMaskTolerance = vec3(u_colorMaskTolerance, u_colorMaskTolerance, u_colorMaskTolerance);\\n\\tif (any(greaterThan(maskDistance, colorMaskTolerance)))\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif // DRAW_MODE_colorMask\\n\\t#endif // DRAW_MODE_silhouette\\n\\n\\t#else // DRAW_MODE_lineSample\\n\\tgl_FragColor = u_lineColor;\\n\\tgl_FragColor.a *= clamp(\\n\\t\\t// Scale the capScale a little to have an aliased region.\\n\\t\\t(u_capScale + u_aliasAmount -\\n\\t\\t\\tu_capScale * 2.0 * distance(v_texCoord, vec2(0.5, 0.5))\\n\\t\\t) / (u_aliasAmount + 1.0),\\n\\t\\t0.0,\\n\\t\\t1.0\\n\\t);\\n\\t#endif // DRAW_MODE_lineSample\\n}\\n\"","module.exports = \"uniform mat4 u_projectionMatrix;\\nuniform mat4 u_modelMatrix;\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nvarying vec2 v_texCoord;\\n\\n#ifdef DRAW_MODE_lineSample\\nuniform float u_positionScalar;\\n#endif\\n\\nvoid main() {\\n    #ifdef DRAW_MODE_lineSample\\n    vec2 position = a_position;\\n    position.y = clamp(position.y * u_positionScalar, -0.5, 0.5);\\n    gl_Position = u_projectionMatrix * u_modelMatrix * vec4(position, 0, 1);\\n    #else\\n    gl_Position = u_projectionMatrix * u_modelMatrix * vec4(a_position, 0, 1);\\n    #endif\\n    v_texCoord = a_texCoord;\\n}\\n\"","const twgl = require('twgl.js');\n\nconst Rectangle = require('./Rectangle');\nconst RenderConstants = require('./RenderConstants');\nconst SVGSkin = require('./SVGSkin');\n\nclass Drawable {\n    /**\n     * An object which can be drawn by the renderer.\n     * @todo double-buffer all rendering state (position, skin, effects, etc.)\n     * @param {!int} id - This Drawable's unique ID.\n     * @constructor\n     */\n    constructor (id) {\n        /** @type {!int} */\n        this._id = id;\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The model matrix, to concat with projection at draw time.\n             * @type {module:twgl/m4.Mat4}\n             */\n            u_modelMatrix: twgl.m4.identity(),\n\n            /**\n             * The color to use in the silhouette draw mode.\n             * @type {Array<number>}\n             */\n            u_silhouetteColor: Drawable.color4fFromID(this._id)\n        };\n\n        this._position = twgl.v3.create(0, 0);\n        this._scale = twgl.v3.create(100, 100);\n        this._direction = 90;\n        this._transformDirty = true;\n        this._rotationMatrix = twgl.m4.identity();\n        this._rotationTransformDirty = true;\n        this._rotationAdjusted = twgl.v3.create();\n        this._rotationCenterDirty = true;\n        this._skinScale = twgl.v3.create(0, 0, 0);\n        this._skinScaleDirty = true;\n        this._inverseMatrix = twgl.m4.identity();\n        this._inverseTransformDirty = true;\n        this._visible = true;\n\n        /** @todo move convex hull functionality, maybe bounds functionality overall, to Skin classes */\n        this._convexHullPoints = null;\n    }\n\n    /**\n     * @returns {number} The ID for this Drawable.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {SVGSkin} the current skin for this Drawable.\n     */\n    get skin () {\n        return this._skin;\n    }\n\n    /**\n     * @param {SVGSkin} newSkin - A new Skin for this Drawable.\n     */\n    set skin (newSkin) {\n        this._skin = newSkin;\n    }\n\n    /**\n     * @returns {Array<number>} the current scaling percentages applied to this Drawable. [100,100] is normal size.\n     */\n    get scale () {\n        return [this._scale[0], this._scale[1]];\n    }\n\n    /**\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering this Drawable.\n     */\n    getUniforms () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        return this._uniforms;\n    }\n\n    /**\n     * @returns {boolean} whether this Drawable is visible.\n     */\n    getVisible () {\n        return this._visible;\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateProperties (properties) {\n        if ('position' in properties && (\n            this._position[0] !== properties.position[0] ||\n            this._position[1] !== properties.position[1])) {\n            this._position[0] = Math.round(properties.position[0]);\n            this._position[1] = Math.round(properties.position[1]);\n        }\n        if ('direction' in properties && this._direction !== properties.direction) {\n            this._direction = properties.direction;\n            this._rotationTransformDirty = true;\n        }\n        if ('scale' in properties && (\n            this._scale[0] !== properties.scale[0] ||\n            this._scale[1] !== properties.scale[1])) {\n            this._scale[0] = properties.scale[0];\n            this._scale[1] = properties.scale[1];\n            this._rotationCenterDirty = true;\n            this._skinScaleDirty = true;\n        }\n        if ('visible' in properties) {\n            this._visible = properties.visible;\n            this.setConvexHullDirty();\n        }\n    }\n\n    /**\n     * Calculate the transform to use when rendering this Drawable.\n     * @private\n     */\n    _calculateTransform () {\n        if (this._rotationTransformDirty) {\n            const rotation = (270 - this._direction) * Math.PI / 180;\n\n            // Calling rotationZ sets the destination matrix to a rotation\n            // around the Z axis setting matrix components 0, 1, 4 and 5 with\n            // cosine and sine values of the rotation.\n            // twgl.m4.rotationZ(rotation, this._rotationMatrix);\n\n            // twgl assumes the last value set to the matrix was anything.\n            // Drawable knows, it was another rotationZ matrix, so we can skip\n            // assigning the values that will never change.\n            const c = Math.cos(rotation);\n            const s = Math.sin(rotation);\n            this._rotationMatrix[0] = c;\n            this._rotationMatrix[1] = s;\n            // this._rotationMatrix[2] = 0;\n            // this._rotationMatrix[3] = 0;\n            this._rotationMatrix[4] = -s;\n            this._rotationMatrix[5] = c;\n            // this._rotationMatrix[6] = 0;\n            // this._rotationMatrix[7] = 0;\n            // this._rotationMatrix[8] = 0;\n            // this._rotationMatrix[9] = 0;\n            // this._rotationMatrix[10] = 1;\n            // this._rotationMatrix[11] = 0;\n            // this._rotationMatrix[12] = 0;\n            // this._rotationMatrix[13] = 0;\n            // this._rotationMatrix[14] = 0;\n            // this._rotationMatrix[15] = 1;\n\n            this._rotationTransformDirty = false;\n        }\n\n        // Adjust rotation center relative to the skin.\n        if (this._rotationCenterDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // let rotationAdjusted = twgl.v3.subtract(\n            //     this.skin.rotationCenter,\n            //     twgl.v3.divScalar(this.skin.size, 2, this._rotationAdjusted),\n            //     this._rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.multiply(\n            //     rotationAdjusted, this._scale, rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.divScalar(\n            //     rotationAdjusted, 100, rotationAdjusted\n            // );\n            // rotationAdjusted[1] *= -1; // Y flipped to Scratch coordinate.\n            // rotationAdjusted[2] = 0; // Z coordinate is 0.\n\n            // Locally assign rotationCenter and skinSize to keep from having\n            // the Skin getter properties called twice while locally assigning\n            // their components for readability.\n            const rotationCenter = this.skin.rotationCenter;\n            const skinSize = this.skin.size;\n            const center0 = rotationCenter[0];\n            const center1 = rotationCenter[1];\n            const skinSize0 = skinSize[0];\n            const skinSize1 = skinSize[1];\n            const scale0 = this._scale[0];\n            const scale1 = this._scale[1];\n\n            const rotationAdjusted = this._rotationAdjusted;\n            rotationAdjusted[0] = (center0 - (skinSize0 / 2)) * scale0 / 100;\n            rotationAdjusted[1] = ((center1 - (skinSize1 / 2)) * scale1 / 100) * -1;\n            // rotationAdjusted[2] = 0;\n\n            this._rotationCenterDirty = false;\n        }\n\n        if (this._skinScaleDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // const scaledSize = twgl.v3.divScalar(\n            //     twgl.v3.multiply(this.skin.size, this._scale),\n            //     100\n            // );\n            // // was NaN because the vectors have only 2 components.\n            // scaledSize[2] = 0;\n\n            // Locally assign skinSize to keep from having the Skin getter\n            // properties called twice.\n            const skinSize = this.skin.size;\n            const scaledSize = this._skinScale;\n            scaledSize[0] = skinSize[0] * this._scale[0] / 100;\n            scaledSize[1] = skinSize[1] * this._scale[1] / 100;\n            // scaledSize[2] = 0;\n\n            this._skinScaleDirty = false;\n        }\n\n        const modelMatrix = this._uniforms.u_modelMatrix;\n\n        // twgl version of the following in function work.\n        // twgl.m4.identity(modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._position, modelMatrix);\n        // twgl.m4.multiply(modelMatrix, this._rotationMatrix, modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._rotationAdjusted, modelMatrix);\n        // twgl.m4.scale(modelMatrix, scaledSize, modelMatrix);\n\n        // Drawable configures a 3D matrix for drawing in WebGL, but most values\n        // will never be set because the inputs are on the X and Y position axis\n        // and the Z rotation axis. Drawable can bring the work inside\n        // _calculateTransform and greatly reduce the ammount of math and array\n        // assignments needed.\n\n        const scale0 = this._skinScale[0];\n        const scale1 = this._skinScale[1];\n        const rotation00 = this._rotationMatrix[0];\n        const rotation01 = this._rotationMatrix[1];\n        const rotation10 = this._rotationMatrix[4];\n        const rotation11 = this._rotationMatrix[5];\n        const adjusted0 = this._rotationAdjusted[0];\n        const adjusted1 = this._rotationAdjusted[1];\n        const position0 = this._position[0];\n        const position1 = this._position[1];\n\n        // Commented assignments show what the values are when the matrix was\n        // instantiated. Those values will never change so they do not need to\n        // be reassigned.\n        modelMatrix[0] = scale0 * rotation00;\n        modelMatrix[1] = scale0 * rotation01;\n        // modelMatrix[2] = 0;\n        // modelMatrix[3] = 0;\n        modelMatrix[4] = scale1 * rotation10;\n        modelMatrix[5] = scale1 * rotation11;\n        // modelMatrix[6] = 0;\n        // modelMatrix[7] = 0;\n        // modelMatrix[8] = 0;\n        // modelMatrix[9] = 0;\n        // modelMatrix[10] = 1;\n        // modelMatrix[11] = 0;\n        modelMatrix[12] = (rotation00 * adjusted0) + (rotation10 * adjusted1) + position0;\n        modelMatrix[13] = (rotation01 * adjusted0) + (rotation11 * adjusted1) + position1;\n        // modelMatrix[14] = 0;\n        // modelMatrix[15] = 1;\n\n        this._transformDirty = false;\n    }\n\n    /**\n     * Set the convex hull to be dirty.\n     * Do this whenever the Drawable's shape has possibly changed.\n     */\n    setConvexHullDirty () {\n        this._convexHullDirty = true;\n    }\n\n    /**\n     * Should the drawable use NEAREST NEIGHBOR or LINEAR INTERPOLATION mode\n     */\n    get useNearest () {\n        // We can't use nearest neighbor unless we are a multiple of 90 rotation\n        if (this._direction % 90 !== 0) {\n            return false;\n        }\n\n        // If the scale of the skin is very close to 100 (0.99999 variance is okay I guess)\n        if (Math.abs(this.scale[0]) > 99 && Math.abs(this.scale[0]) < 101 &&\n            Math.abs(this.scale[1]) > 99 && Math.abs(this.scale[1]) < 101) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Calculate a color to represent the given ID number. At least one component of\n     * the resulting color will be non-zero if the ID is not RenderConstants.ID_NONE.\n     * @param {int} id The ID to convert.\n     * @returns {Array<number>} An array of [r,g,b,a], each component in the range [0,1].\n     */\n    static color4fFromID (id) {\n        id -= RenderConstants.ID_NONE;\n        const r = ((id >> 0) & 255) / 255.0;\n        const g = ((id >> 8) & 255) / 255.0;\n        const b = ((id >> 16) & 255) / 255.0;\n        return [r, g, b, 1.0];\n    }\n}\n\nmodule.exports = Drawable;\n","class Rectangle {\n    /**\n     * A utility for creating and comparing axis-aligned rectangles.\n     * Rectangles are always initialized to the \"largest possible rectangle\";\n     * use one of the init* methods below to set up a particular rectangle.\n     * @constructor\n     */\n    constructor () {\n        this.left = -Infinity;\n        this.right = Infinity;\n        this.bottom = -Infinity;\n        this.top = Infinity;\n    }\n\n    /**\n     * Initialize a Rectangle from given Scratch-coordinate bounds.\n     * @param {number} left Left bound of the rectangle.\n     * @param {number} right Right bound of the rectangle.\n     * @param {number} bottom Bottom bound of the rectangle.\n     * @param {number} top Top bound of the rectangle.\n     */\n    initFromBounds (left, right, bottom, top) {\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n        this.top = top;\n    }\n\n    /**\n     * Initialize a Rectangle to the minimum AABB around a set of points.\n     * @param {Array<Array<number>>} points Array of [x, y] points.\n     */\n    initFromPointsAABB (points) {\n        this.left = Infinity;\n        this.right = -Infinity;\n        this.top = -Infinity;\n        this.bottom = Infinity;\n\n        for (let i = 0; i < points.length; i++) {\n            const x = points[i][0];\n            const y = points[i][1];\n            if (x < this.left) {\n                this.left = x;\n            }\n            if (x > this.right) {\n                this.right = x;\n            }\n            if (y > this.top) {\n                this.top = y;\n            }\n            if (y < this.bottom) {\n                this.bottom = y;\n            }\n        }\n    }\n\n    /**\n     * Determine if this Rectangle intersects some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if intersecting.\n     * @return {boolean} True if this Rectangle intersects other.\n     */\n    intersects (other) {\n        return (\n            this.left <= other.right &&\n            other.left <= this.right &&\n            this.top >= other.bottom &&\n            other.top >= this.bottom\n        );\n    }\n\n    /**\n     * Determine if this Rectangle fully contains some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if fully contained.\n     * @return {boolean} True if this Rectangle fully contains other.\n     */\n    contains (other) {\n        return (\n            other.left > this.left &&\n            other.right < this.right &&\n            other.top < this.top &&\n            other.bottom > this.bottom\n        );\n    }\n\n    /**\n     * Clamp a Rectangle to bounds.\n     * @param {number} left Left clamp.\n     * @param {number} right Right clamp.\n     * @param {number} bottom Bottom clamp.\n     * @param {number} top Top clamp.\n     */\n    clamp (left, right, bottom, top) {\n        this.left = Math.max(this.left, left);\n        this.right = Math.min(this.right, right);\n        this.bottom = Math.max(this.bottom, bottom);\n        this.top = Math.min(this.top, top);\n        // Ensure rectangle coordinates in order.\n        this.left = Math.min(this.left, this.right);\n        this.right = Math.max(this.right, this.left);\n        this.bottom = Math.min(this.bottom, this.top);\n        this.top = Math.max(this.top, this.bottom);\n    }\n\n    /**\n     * Push out the Rectangle to integer bounds.\n     */\n    snapToInt () {\n        this.left = Math.floor(this.left);\n        this.right = Math.ceil(this.right);\n        this.bottom = Math.floor(this.bottom);\n        this.top = Math.ceil(this.top);\n    }\n\n    /**\n     * Compute the intersection of two bounding Rectangles.\n     * Could be an impossible box if they don't intersect.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static intersect (a, b, result = new Rectangle()) {\n        result.left = Math.max(a.left, b.left);\n        result.right = Math.min(a.right, b.right);\n        result.top = Math.min(a.top, b.top);\n        result.bottom = Math.max(a.bottom, b.bottom);\n\n        return result;\n    }\n\n    /**\n     * Compute the union of two bounding Rectangles.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static union (a, b, result = new Rectangle()) {\n        result.left = Math.min(a.left, b.left);\n        result.right = Math.max(a.right, b.right);\n        // Scratch Space - +y is up\n        result.top = Math.max(a.top, b.top);\n        result.bottom = Math.min(a.bottom, b.bottom);\n        return result;\n    }\n\n    /**\n     * Width of the Rectangle.\n     * @return {number} Width of rectangle.\n     */\n    get width () {\n        return Math.abs(this.left - this.right);\n    }\n\n    /**\n     * Height of the Rectangle.\n     * @return {number} Height of rectangle.\n     */\n    get height () {\n        return Math.abs(this.top - this.bottom);\n    }\n\n}\n\nmodule.exports = Rectangle;\n","/** @module RenderConstants */\n\n/**\n * Various constants meant for use throughout the renderer.\n * @enum\n */\nmodule.exports = {\n    /**\n     * The ID value to use for \"no item\" or when an object has been disposed.\n     * @const {int}\n     */\n    ID_NONE: -1,\n\n    /**\n     * Optimize for fewer than this number of Drawables sharing the same Skin.\n     * Going above this may cause middleware warnings or a performance penalty but should otherwise behave correctly.\n     * @const {int}\n     */\n    SKIN_SHARE_SOFT_LIMIT: 301,\n\n    /**\n     * @enum {string}\n     */\n    Events: {\n        /**\n         * NativeSizeChanged event\n         *\n         * @event RenderWebGL#event:NativeSizeChanged\n         * @type {object}\n         * @property {Array<int>} newSize - the new size of the renderer\n         */\n        NativeSizeChanged: 'NativeSizeChanged'\n    }\n};\n","const EventEmitter = require('events');\n\nconst hull = require('hull.js');\nconst twgl = require('twgl.js');\n\nconst Drawable = require('./Drawable');\nconst Rectangle = require('./Rectangle');\nconst ShaderManager = require('./ShaderManager');\nconst RenderConstants = require('./RenderConstants');\nconst SVGSkin = require('./SVGSkin');\n\nconst __candidatesBounds = new Rectangle();\nconst __touchingColor = new Uint8ClampedArray(4);\nconst __blendColor = new Uint8ClampedArray(4);\n\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nconst MAX_TOUCH_SIZE = [3, 3];\n\n\nclass RenderWebGL extends EventEmitter {\n    /**\n     * Ask TWGL to create a rendering context with the attributes used by this renderer.\n     * @param {canvas} canvas - attach the context to this canvas.\n     * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).\n     * @private\n     */\n    static _getContext (canvas) {\n        return twgl.getWebGLContext(canvas, {alpha: false, stencil: true});\n    }\n\n    /**\n     * Create a renderer for drawing Scratch sprites to a canvas using WebGL.\n     * Coordinates will default to Scratch 2.0 values if unspecified.\n     * The stage's \"native\" size will be calculated from the these coordinates.\n     * For example, the defaults result in a native size of 480x360.\n     * Queries such as \"touching color?\" will always execute at the native size.\n     * @see RenderWebGL#setStageSize\n     * @see RenderWebGL#resize\n     * @param {canvas} canvas The canvas to draw onto.\n     * @param {int} [xLeft=-240] The x-coordinate of the left edge.\n     * @param {int} [xRight=240] The x-coordinate of the right edge.\n     * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.\n     * @param {int} [yTop=180] The y-coordinate of the top edge.\n     * @constructor\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (canvas, xLeft, xRight, yBottom, yTop) {\n        super();\n\n        /** @type {WebGLRenderingContext} */\n        const gl = this._gl = RenderWebGL._getContext(canvas);\n        if (!gl) {\n            throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n        }\n        /** @type {Drawable[]} */\n        this._allDrawables = [];\n\n        /** @type {Skin[]} */\n        this._allSkins = [];\n\n        /** @type {Array<int>} */\n        this._drawList = [];\n\n        // A list of layer group names in the order they should appear\n        // from furthest back to furthest in front.\n        /** @type {Array<String>} */\n        this._groupOrdering = [];\n\n        /**\n         * @typedef LayerGroup\n         * @property {int} groupIndex The relative position of this layer group in the group ordering\n         * @property {int} drawListOffset The absolute position of this layer group in the draw list\n         * This number gets updated as drawables get added to or deleted from the draw list.\n         */\n\n        // Map of group name to layer group\n        /** @type {Object.<string, LayerGroup>} */\n        this._layerGroups = {};\n\n        /** @type {int} */\n        this._nextDrawableId = RenderConstants.ID_NONE + 1;\n\n        /** @type {int} */\n        this._nextSkinId = RenderConstants.ID_NONE + 1;\n\n        /** @type {ShaderManager} */\n        this._shaderManager = new ShaderManager(gl);\n\n        /** @type {module:twgl/m4.Mat4} */\n        this._projection = twgl.m4.identity();\n\n        /** @type {HTMLCanvasElement} */\n        this._tempCanvas = document.createElement('canvas');\n\n        /** @type {any} */\n        this._regionId = null;\n\n        /** @type {function} */\n        this._exitRegion = null;\n\n        /** @type {Array.<snapshotCallback>} */\n        this._snapshotCallbacks = [];\n\n        this._createGeometry();\n\n        this.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this.setBackgroundColor(1, 1, 1);\n        this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n        this.resize(this._nativeSize[0], this._nativeSize[1]);\n\n        gl.disable(gl.DEPTH_TEST);\n        /** @todo disable when no partial transparency? */\n        gl.enable(gl.BLEND);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n    }\n\n    /**\n     * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.\n     */\n    get gl () {\n        return this._gl;\n    }\n\n    /**\n     * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.\n     */\n    get canvas () {\n        return this._gl && this._gl.canvas;\n    }\n\n    /**\n     * Set the physical size of the stage in device-independent pixels.\n     * This will be multiplied by the device's pixel ratio on high-DPI displays.\n     * @param {int} pixelsWide The desired width in device-independent pixels.\n     * @param {int} pixelsTall The desired height in device-independent pixels.\n     */\n    resize (pixelsWide, pixelsTall) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        this._gl.canvas.width = pixelsWide * pixelRatio;\n        this._gl.canvas.height = pixelsTall * pixelRatio;\n    }\n\n    /**\n     * Set the background color for the stage. The stage will be cleared with this\n     * color each frame.\n     * @param {number} red The red component for the background.\n     * @param {number} green The green component for the background.\n     * @param {number} blue The blue component for the background.\n     */\n    setBackgroundColor (red, green, blue) {\n        this._backgroundColor = [red, green, blue, 1];\n    }\n\n    /**\n     * Set logical size of the stage in Scratch units.\n     * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.\n     * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.\n     * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.\n     * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.\n     */\n    setStageSize (xLeft, xRight, yBottom, yTop) {\n        this._xLeft = xLeft;\n        this._xRight = xRight;\n        this._yBottom = yBottom;\n        this._yTop = yTop;\n\n        // swap yBottom & yTop to fit Scratch convention of +y=up\n        this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n\n        this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n\n    /**\n     * Set the \"native\" size of the stage, which is used for pen, query renders, etc.\n     * @param {int} width - the new width to set.\n     * @param {int} height - the new height to set.\n     * @private\n     * @fires RenderWebGL#event:NativeSizeChanged\n     */\n    _setNativeSize (width, height) {\n        this._nativeSize = [width, height];\n        this.emit(RenderConstants.Events.NativeSizeChanged, {newSize: this._nativeSize});\n    }\n\n    /**\n     * Create a new SVG skin.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     * @returns {!int} the ID for the new skin.\n     */\n    createSVGSkin (svgData, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new Drawable and add it to the scene.\n     * @param {string} group Layer group to add the drawable to\n     * @returns {int} The ID of the new Drawable.\n     */\n    createDrawable (group) {\n        if (!group || !this._layerGroups.hasOwnProperty(group)) {\n            return;\n        }\n        const drawableID = this._nextDrawableId++;\n        const drawable = new Drawable(drawableID);\n        this._allDrawables[drawableID] = drawable;\n        this._addToDrawList(drawableID, group);\n\n        drawable.skin = null;\n\n        return drawableID;\n    }\n\n    /**\n     * Set the layer group ordering for the renderer.\n     * @param {Array<string>} groupOrdering The ordered array of layer group\n     * names\n     */\n    setLayerGroupOrdering (groupOrdering) {\n        this._groupOrdering = groupOrdering;\n        for (let i = 0; i < this._groupOrdering.length; i++) {\n            this._layerGroups[this._groupOrdering[i]] = {\n                groupIndex: i,\n                drawListOffset: 0\n            };\n        }\n    }\n\n    _addToDrawList (drawableID, group) {\n        const currentLayerGroup = this._layerGroups[group];\n        const currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n\n        const drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n        this._drawList.splice(drawListOffset, 0, drawableID);\n\n        this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n\n    _updateOffsets (updateType, currentGroupOrderingIndex) {\n        for (let i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n            const laterGroupName = this._groupOrdering[i];\n            if (updateType === 'add') {\n                this._layerGroups[laterGroupName].drawListOffset++;\n            } else if (updateType === 'delete'){\n                this._layerGroups[laterGroupName].drawListOffset--;\n            }\n        }\n    }\n\n    get _visibleDrawList () {\n        return this._drawList.filter(id => this._allDrawables[id]._visible);\n    }\n\n    // Given a layer group, return the index where it ends (non-inclusive),\n    // e.g. the returned index does not have a drawable from this layer group in it)\n    _endIndexForKnownLayerGroup (layerGroup) {\n        const groupIndex = layerGroup.groupIndex;\n        if (groupIndex === this._groupOrdering.length - 1) {\n            return this._drawList.length;\n        }\n        return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n\n    /**\n     * Draw all current drawables and present the frame on the canvas.\n     */\n    draw () {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n\n        twgl.bindFramebufferInfo(gl, null);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor.apply(gl, this._backgroundColor);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection);\n        if (this._snapshotCallbacks.length > 0) {\n            const snapshot = gl.canvas.toDataURL();\n            this._snapshotCallbacks.forEach(cb => cb(snapshot));\n            this._snapshotCallbacks = [];\n        }\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @param {int} drawableID The ID of the Drawable to update.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateDrawableProperties (drawableID, properties) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            /**\n             * @todo fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n             * Right now this happens so much on some projects that a warning or exception here can hang the browser.\n             */\n            return;\n        }\n        if ('skinId' in properties) {\n            drawable.skin = this._allSkins[properties.skinId];\n        }\n        drawable.updateProperties(properties);\n    }\n\n    /* ******\n     * Truly internal functions: these support the functions above.\n     ********/\n\n    /**\n     * Build geometry (vertex and index) buffers.\n     * @private\n     */\n    _createGeometry () {\n        const quad = {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    -0.5, -0.5,\n                    0.5, -0.5,\n                    -0.5, 0.5,\n                    -0.5, 0.5,\n                    0.5, -0.5,\n                    0.5, 0.5\n                ]\n            },\n            a_texCoord: {\n                numComponents: 2,\n                data: [\n                    1, 0,\n                    0, 0,\n                    1, 1,\n                    1, 1,\n                    0, 0,\n                    0, 1\n                ]\n            }\n        };\n        this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n\n    /**\n     * Respond to a change in the \"native\" rendering size. The native size is used by buffers which are fixed in size\n     * regardless of the size of the main render target. This includes the buffers used for queries such as picking and\n     * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.\n     * @param {object} event - The change event.\n     * @private\n     */\n    onNativeSizeChanged (event) {\n        const [width, height] = event.newSize;\n\n        const gl = this._gl;\n        const attachments = [\n            {format: gl.RGBA},\n            {format: gl.DEPTH_STENCIL}\n        ];\n\n        if (!this._pickBufferInfo) {\n            this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n        }\n\n        /** @todo should we create this on demand to save memory? */\n        // A 480x360 32-bpp buffer is 675 KiB.\n        if (this._queryBufferInfo) {\n            twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n        } else {\n            this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n        }\n    }\n\n    /**\n     * Forcefully exit the current region returning to a common inbetween GL\n     * state.\n     */\n    _doExitDrawRegion () {\n        if (this._exitRegion !== null) {\n            this._exitRegion();\n        }\n        this._exitRegion = null;\n    }\n\n    /**\n     * Draw a set of Drawables, by drawable ID\n     * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.\n     * @param {module:twgl/m4.Mat4} projection The projection matrix to use.\n     * @param {object} [opts] Options for drawing\n     * @param {idFilterFunc} opts.filter An optional filter function.\n     * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.\n     * @param {int} opts.effectMask Bitmask for effects to allow\n     * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)\n     * @private\n     */\n    _drawThese (drawables, drawMode, projection, opts = {}) {\n\n        const gl = this._gl;\n        let currentShader = null;\n\n        const numDrawables = drawables.length;\n        for (let drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n            const drawableID = drawables[drawableIndex];\n\n            // If we have a filter, check whether the ID fails\n            if (opts.filter && !opts.filter(drawableID)) continue;\n\n            const drawable = this._allDrawables[drawableID];\n            /** @todo check if drawable is inside the viewport before anything else */\n\n            // Hidden drawables (e.g., by a \"hide\" block) are not drawn unless\n            // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).\n            if (!drawable.getVisible() && !opts.ignoreVisibility) continue;\n\n            // Combine drawable scale with the native vs. backing pixel ratio\n            const drawableScale = [\n                drawable.scale[0] * this._gl.canvas.width / this._nativeSize[0],\n                drawable.scale[1] * this._gl.canvas.height / this._nativeSize[1]\n            ];\n\n            // If the skin or texture isn't ready yet, skip it.\n            if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n\n            const uniforms = {};\n\n            const newShader = this._shaderManager.getShader(drawMode, 0);\n\n            // Manually perform region check. Do not create functions inside a\n            // loop.\n            if (this._regionId !== newShader) {\n                this._doExitDrawRegion();\n                this._regionId = newShader;\n\n                currentShader = newShader;\n                gl.useProgram(currentShader.program);\n                twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n                Object.assign(uniforms, {\n                    u_projectionMatrix: projection,\n                    u_fudge: window.fudge || 0\n                });\n            }\n\n            Object.assign(uniforms,\n                drawable.skin.getUniforms(drawableScale),\n                drawable.getUniforms());\n\n            // Apply extra uniforms after the Drawable's, to allow overwriting.\n            if (opts.extraUniforms) {\n                Object.assign(uniforms, opts.extraUniforms);\n            }\n\n            if (uniforms.u_skin) {\n                twgl.setTextureParameters(\n                    gl, uniforms.u_skin, {minMag: drawable.useNearest ? gl.NEAREST : gl.LINEAR}\n                );\n            }\n\n            twgl.setUniforms(currentShader, uniforms);\n            \n            /* adjust blend function for this skin */\n            if (drawable.skin.hasPremultipliedAlpha){\n                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            } else {\n                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            }\n            \n            twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n        }\n\n        this._regionId = null;\n    }\n}\n\nmodule.exports = RenderWebGL;\n","const twgl = require('twgl.js');\nconst EventEmitter = require('events');\nconst SvgRenderer = require('scratch-svg-renderer').SVGRenderer;\n\nclass SVGSkin extends EventEmitter {\n    /**\n     * Create a new SVG skin.\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     * @constructor\n     * @extends Skin\n     */\n    constructor (id, renderer) {\n        super();\n\n        /** @type {int} */\n        this._id = id;\n\n        /** @type {Vec3} */\n        this._rotationCenter = twgl.v3.create(0, 0);\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The nominal (not necessarily current) size of the current skin.\n             * @type {Array<number>}\n             */\n            u_skinSize: [0, 0],\n\n            /**\n             * The actual WebGL texture object for the skin.\n             * @type {WebGLTexture}\n             */\n            u_skin: null\n        };\n\n        /** @type {RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {SvgRenderer} */\n        this._svgRenderer = new SvgRenderer();\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this skin.\n     */\n    get size () {\n        return this._svgRenderer.size;\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture () {\n        return this._texture;\n    }\n\n    /**\n     * @returns {Vec3} the origin, in object space, about which this Skin should rotate.\n     */\n    get rotationCenter () {\n        return this._rotationCenter;\n    }\n\n    /**\n     * Update and returns the uniforms for this skin.\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering with this Skin.\n     */\n    getUniforms (scale) {\n        this._uniforms.u_skin = this.getTexture(scale);\n        this._uniforms.u_skinSize = this.size;\n        return this._uniforms;\n    }\n\n    /**\n     * Set the origin, in object space, about which this Skin should rotate.\n     */\n    setRotationCenter () {\n        this._rotationCenter[0] = this.size[0] / 2;\n        this._rotationCenter[1] = this.size[1] / 2;\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided SVG data.\n     * @param {string} svgData - new SVG to use.\n     * calculated from the bounding box\n\\     */\n    setSVG (svgData) {\n        this._svgRenderer.fromString(svgData, 1, () => {\n            const gl = this._renderer.gl;\n\n            // Pull out the ImageData from the canvas. ImageData speeds up\n            // updating Silhouette and is better handled by more browsers in\n            // regards to memory.\n            const canvas = this._svgRenderer.canvas;\n            const context = canvas.getContext('2d');\n            const textureData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const textureOptions = {\n                auto: true,\n                wrap: gl.CLAMP_TO_EDGE,\n                src: textureData\n            };\n\n            this._texture = twgl.createTexture(gl, textureOptions);\n            this.setRotationCenter();\n        });\n    }\n\n}\n\nmodule.exports = SVGSkin;\n","const twgl = require('twgl.js');\n\n\nclass ShaderManager {\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for\n     * @constructor\n     */\n    constructor (gl) {\n        this._gl = gl;\n\n        /**\n         * The cache of all shaders compiled so far, filled on demand.\n         * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}\n         * @private\n         */\n        this._shaderCache = {};\n        for (const modeName in ShaderManager.DRAW_MODE) {\n            if (ShaderManager.DRAW_MODE.hasOwnProperty(modeName)) {\n                this._shaderCache[modeName] = [];\n            }\n        }\n    }\n\n    /**\n     * Fetch the shader for a particular set of active effects.\n     * Build the shader if necessary.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The shader's program info.\n     */\n    getShader (drawMode, effectBits) {\n        const cache = this._shaderCache[drawMode];\n        if (drawMode === ShaderManager.DRAW_MODE.silhouette) {\n            // Silhouette mode isn't affected by these effects.\n            effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);\n        }\n        let shader = cache[effectBits];\n        if (!shader) {\n            shader = cache[effectBits] = this._buildShader(drawMode, effectBits);\n        }\n        return shader;\n    }\n\n    /**\n     * Build the shader for a particular set of active effects.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The new shader's program info.\n     * @private\n     */\n    _buildShader (drawMode, effectBits) {\n        const numEffects = ShaderManager.EFFECTS.length;\n\n        const defines = [\n            `#define DRAW_MODE_${drawMode}`\n        ];\n        for (let index = 0; index < numEffects; ++index) {\n            if ((effectBits & (1 << index)) !== 0) {\n                defines.push(`#define ENABLE_${ShaderManager.EFFECTS[index]}`);\n            }\n        }\n\n        const definesText = `${defines.join('\\n')}\\n`;\n\n        /* eslint-disable global-require */\n        const vsFullText = definesText + require('raw-loader!./shaders/sprite.vert');\n        const fsFullText = definesText + require('raw-loader!./shaders/sprite.frag');\n        /* eslint-enable global-require */\n\n        return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);\n    }\n}\n\n/**\n * @typedef {object} ShaderManager.Effect\n * @prop {int} mask - The bit in 'effectBits' representing the effect.\n * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range\n *   0..100 or -100..100) and maps it to a value useful to the shader. This\n *   mapping may not be reversible.\n * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.\n */\n\n/**\n * Mapping of each effect name to info about that effect.\n * @enum {ShaderManager.Effect}\n */\nShaderManager.EFFECT_INFO = {\n    /** Color effect */\n    color: {\n        uniformName: 'u_color',\n        mask: 1 << 0,\n        converter: x => (x / 200) % 1,\n        shapeChanges: false\n    },\n    /** Fisheye effect */\n    fisheye: {\n        uniformName: 'u_fisheye',\n        mask: 1 << 1,\n        converter: x => Math.max(0, (x + 100) / 100),\n        shapeChanges: true\n    },\n    /** Whirl effect */\n    whirl: {\n        uniformName: 'u_whirl',\n        mask: 1 << 2,\n        converter: x => -x * Math.PI / 180,\n        shapeChanges: true\n    },\n    /** Pixelate effect */\n    pixelate: {\n        uniformName: 'u_pixelate',\n        mask: 1 << 3,\n        converter: x => Math.abs(x) / 10,\n        shapeChanges: true\n    },\n    /** Mosaic effect */\n    mosaic: {\n        uniformName: 'u_mosaic',\n        mask: 1 << 4,\n        converter: x => {\n            x = Math.round((Math.abs(x) + 10) / 10);\n            /** @todo cap by Math.min(srcWidth, srcHeight) */\n            return Math.max(1, Math.min(x, 512));\n        },\n        shapeChanges: true\n    },\n    /** Brightness effect */\n    brightness: {\n        uniformName: 'u_brightness',\n        mask: 1 << 5,\n        converter: x => Math.max(-100, Math.min(x, 100)) / 100,\n        shapeChanges: false\n    },\n    /** Ghost effect */\n    ghost: {\n        uniformName: 'u_ghost',\n        mask: 1 << 6,\n        converter: x => 1 - (Math.max(0, Math.min(x, 100)) / 100),\n        shapeChanges: false\n    }\n};\n\n/**\n * The name of each supported effect.\n * @type {Array}\n */\nShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);\n\n/**\n * The available draw modes.\n * @readonly\n * @enum {string}\n */\nShaderManager.DRAW_MODE = {\n    /**\n     * Draw normally.\n     */\n    default: 'default',\n\n    /**\n     * Draw a silhouette using a solid color.\n     */\n    silhouette: 'silhouette',\n\n    /**\n     * Draw only the parts of the drawable which match a particular color.\n     */\n    colorMask: 'colorMask',\n\n    /**\n     * Sample a \"texture\" to draw a line with caps.\n     */\n    lineSample: 'lineSample',\n\n    /**\n     * Draw normally except for pre-multiplied alpha\n     */\n    stamp: 'stamp'\n};\n\nmodule.exports = ShaderManager;\n","const RenderWebGL = require('./RenderWebGL');\n\n/**\n * Export for NPM & Node.js\n * @type {RenderWebGL}\n */\nmodule.exports = RenderWebGL;\n","module.exports = require(\"events\");","module.exports = require(\"hull.js\");","module.exports = require(\"scratch-svg-renderer\");","module.exports = require(\"twgl.js\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AA/NA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AA2MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;ACzTA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAmCA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;AAxCA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAoBA;;;;;;;;;;;;;;AC1KA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AARA;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;;;;;;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;AAqEA;AACA;AACA;;;;;;;;;AAcA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AAFA;AAWA;AACA;AACA;AAFA;AAZA;AAwBA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAhWA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AA8HA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AA9OA;AACA;AAucA;;;;;;;;;;;;;;;;;;;;;;ACheA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAqCA;AACA;AACA;;;;;;;;;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;;;AA/DA;AACA;AACA;;;AAcA;AACA;AACA;;;;AApEA;AACA;AAoHA;;;;;;;;;;;;;;;;;;ACzHA;AACA;AAEA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;AASA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAhDA;AACA;AAuDA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AAxBA;AACA;AA0BA;;;;;;;;;;;;;;ACrLA;AACA;AACA;;;;AAIA;;;;;;;;;;;ACNA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}